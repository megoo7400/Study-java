# 笔记

[笔记](#笔记)

- [笔记](#笔记)
  - [注释](#注释)
  - [关键字](#关键字)
  - [常量](#常量)
  - [数据类型](#数据类型)
    - [基本数据类型](#基本数据类型)
  - [变量](#变量)
  - [数据的存储形式: 二进制](#数据的存储形式-二进制)
  - [ASCII编码表](#ascii编码表)
  - [表示符](#表示符)
  - [java语言](#java语言)
    - [类型转换](#类型转换)
    - [运算符](#运算符)
    - [案列知识 ---> 键盘录入技术](#案列知识-----键盘录入技术)
  - [流程控制](#流程控制)
      - [顺序结构](#顺序结构)
      - [分之结构](#分之结构)
      - [循环结构](#循环结构)
  - [数组](#数组)
  - [方法](#方法)
  - [学什么](#学什么)
  - [综合案列](#综合案列)
  - [**面向对象编程(基础)**](#面向对象编程基础)
      - [设计对象](#设计对象)
      - [对象内存图](#对象内存图)
      - [面向对象编程训练](#面向对象编程训练)
      - [构造器](#构造器)
      - [**this 关键字**](#this-关键字)
      - [封装](#封装)
      - [标准Javabean](#标准javabean)
      - [使用标准 JavaBean 改造购物车模块](#使用标准-javabean-改造购物车模块)
      - [补充知识:成员变量/局部变量的区别](#补充知识成员变量局部变量的区别)
  - [常用API(应用程序编程接口)](#常用api应用程序编程接口)
  - [进阶知识](#进阶知识)
  - [ATM 系统](#atm-系统)
  - [面向对象进阶](#面向对象进阶)
  - [继承(面向对象三大之一)](#继承面向对象三大之一)
  - [接口](#接口)
  - [常用API](#常用api)
  - [集合的概述](#集合的概述)
    - [collection 集合的体系结构(接口...是接口)](#collection-集合的体系结构接口是接口)
    - [常用API](#常用api-1)

## 注释

- 当行注释 //
- 多行注释 /*xxxxxx*/

## 关键字

- 关键紫的字母小写

## 常量

- 6类常量

![常量](first/常量.png)

## 数据类型

- 存储单位: k, kb, m, G

### 基本数据类型

![数据类型](first/数据类型.png)

## 变量

- 变量的定义
  - 可以发生改变的量
- 变量语法
  - 变量名:数据类型:变量值
  - `int a = 10`
  - a , or a = 20 (范例)

- 变量常见的问题:
  - 变量的类型确定,需要复制该类型的值;
  - 同一个范围内不能定义同一个变量;(赋值是可以的)
  - 定义可以不给初始化,使用的时候需要给到初始值;

## 数据的存储形式: 二进制

## ASCII编码表

![ASCII](./ASCII.png)

## 表示符

- 基本:数字,字母,下划线,$组成;
- 不能是数字开始,不能是关键字,区分大小小;
- 命名规则:
  - 驼峰模式;

## java语言

- 数据类型的转换;
- 数据的基本运算,逻辑运算;
- java调用写好的程序;

### 类型转换

- 自动类型转换
  - 类型小的变量,可以直接赋值给类型范围大的变量
  - // a : 00001100
    // b : 0*0* 0* 00001100
  - byte -> short ->(char ->) int -> long -> float -> double

- 表达式的自动转换
  - 结果的数据类型:
  - byte,short,char -> int -> long -> float -> double
  - 表达式的最高的数据类型决定.
  - java

  ```java

     byte a = 10;
     int b = 20;
     double c = 2.0;
     double rs = a + b + c;
     // rs 的数据类型由 c 决定
     ```

- 强制类型转换
  - java

  ```java
  int a = gongneng();
  byte gongneng2(a);
  // 大范围的数据*赋值*给小范围类型的变量
  // 报错: 
  ```

  - 强制转换:
    - 数据类型 变量名 = (强制数据类型) 变量名
  - 数据溢出
  - 浮点型转换为整型小数部分直接丢弃

### 运算符

- 基本算数运算符
  - +, -, /, %
- +符号做连接符
  - 能算则算,不能则连接一起
- 自增自减
  - ++, --,可以放在变量前后
  - 只能操作变量,不能放在常量
  - ++a,先加后赋值....
- 赋值运算符
  - +=, -=, *=, /=, %=
  - 加厚赋值,减后赋值,乘后赋值,取余后赋值
  - 改写法带有强制类型转换
- 关系运算
  - ==, !=, >, <, <=, >=
  - 结果为boolean型
- 逻辑运算
  - 与-&, 或-|,非-!,异或-^
  - && -> 左边是FALSE,右边不执行
  - || -> 左边为TRUE,右边不执行
- 三元运算
  - 条件? 值1:值2
- 运算符优先级
  - && 优先级高于 ||

### 案列知识 ---> 键盘录入技术

- API,应用程序编程接口,写好的程序,直接调用
- 导入包 ```import```

## 流程控制

#### 顺序结构

- 默认

#### 分之结构

- if, switch,switch穿透
  - if 结构
    - 根据判定的结构,决定执行某个分支代码
    - 三种格式:

    ```java
    格式一:
    if(条件){
      语句体
    }
    格式二:
    if(条件){
      语句体1
    }else{
      语句体2
    }
    格式三:
    if(条件){
      语句1
    }else if{
      语句2
    }else if{
      语句3
    }
    ...
    else{
      语句n+1
    }
    ```

  - switch 结构

   ```java
   switch(条件){
    case 值1:
       执行代码;
       break;
     case 值2:
       执行代码;
       break;
     case 值3:
       执行代码;
       break;
     case n+1:
       执行代码;
       break;
     default:
       执行代码;
   }
   ```

- if 是区间,switch是值来匹配(表达式条件:byte,short,int,char),枚举,string;
- case值不能重复,只能是常量,不能是变量;
- 不要忘记break,否则会出现穿透现象
- 穿透性可以解决多个分支一样的代码时,可以试用.

#### 循环结构

- for, while, do .. while
- for
  - 重复次数执行的结构

   ```java
  格式:
  for (初始化语句;循环条件;迭代语句){
    循环体语句(重复执行);
  }
  ```

- for 案例
  - n 个数的和,奇数,偶数
  - 水仙花数

- while
  
  ```java
  while(条件){
    循环体语句;
    迭代语句;
  }
  ```

  - 功能上for与while一样;
  - 不知道循环次数:while;知道次数:for;
- while 案例
  - 珠峰高度与纸张折叠高度的案例
- do.. while
  - 先执行在循环
  
  ```java
  初始化语句;
  do {
    循环体语句;
    迭代语句;
  } while (循环条件)
  ```

- do.. while 案例
- **总结**:
  - for while 是一样的,次数:for ;while不知道次数;
  - do-while 先执行一次,在判断循环条件,执行次数;
- 死循环
  - 一直循环,不干预会不会停止下去
- 嵌套循环
  - 循环中包含另一个循环.
  - 外部循环执行一次,内部完整的执行循环
- 跳转关键字: break, continue
  - break 跳出并结束当前循环的执行,if 无作用
  - 用于跳出当前循环的档次执行,并执行下个语句,只能用在循环里
- 案例技术: 随机数 Random 类
  - random 的使用
  - 倒包,创建对象,输入随机数

## 数组

- 用内存存储一批**同一种类型**的**内存区域**
- 表示数组: int[] arr = {10,20,30,50,40}
- String[] names = {"牛二","西门","全蛋"}
- 定义数据,获取数据,修改数据,怎么解决实际问题,数据内存的原理,注意点.
  - 静态初始化数据
    - 访问,注意事项

    ```java
    // 完整格式
    数据类型[] 数组名 = new 数据类型[]{元素}
    double[] scores = new double[]{89.0,}
    //简化格式
    int age[] = {1,2,3}
    ```

    - 数组名存的是该数组的**地址**
    - 访问数组里面的数据
    - 索引号来访问,```arr[0]```
    - 数组的长度的访问,```arr.length```
    - 类型放该类型的数据
    - 数组一旦定义,长度和类型就固定了.
  - 动态化数据
    - 初始化默认值
    - 自定义数据的长度和类型,一开始不存数据

    ```java
    数据类型[] 数组名 = new 数据类型[长度]
    int[] arr = new int[10];
    ```

    - 知道数据,用静态,知道长度用动态数组.
- 数组的遍历
  - 一个一个的访问一边
  - 用for循环访问
- 数组的案列
  - 数组求和
  - 数组的最大值判断\
  - 猜数字游戏
  - 随机排名
  - 数组排序
    - 冒泡
    - 最大值放到最后面(最小值放到最前面)
    - 选择
    - 快速
    - 插入
  - 数组相关技术
    - 二分
    - 分块
    - 哈希
- 数组的内存图
![数组](array.png)

- 栈: 方法运行时所进入的内存,变量也在
- 堆: new 出来的东西会在这块内存中开辟空间并产生地址
- 方法区: 字节码文件加载时进入的内存
- 本地方法栈
- 寄存器
![数组1](array01.png)
![数组2](array02.png)
- 两个变量指向同一个数组
![数组3](array03.png)
- 数组的常见问题
  - 访问元素位置超过范围,数组索引越界异常
  - 如果数组变量值没有存储数组的地址,而是null,空指针异常
- Debug 工具的使用
  - 调试工具
![debug](Debug.png)

## 方法

- 概述,定义,常见问题
- 形参可以有,可以多个,但不不能初始化.
  - 实现一定功能的模块
  - 提高代码复用性
  - 让代码逻辑更清晰
- 注意事项:
  - 方法编写顺序没有关系
  - 方法与方法之间是平行关系,不能嵌套
  - void 的类型方法,不能用 return
  - return 下面不能再写代码,是执行不到的语句.
  - 方法不调用就不执行,严格匹配参数的类型
  - 有返回值得方法可以用变量接,甚至直接调用,无返回值的方法只能直接调用

```java
public class MothodDemo {

    public static void main(String[] args) {
       
        System.out.println(sum(10,20));
    }
    // 方法写法
    public static int sum(int a , int b) {
        int c = a + b;
        return c;
    }
}
```

## 学什么

- 定义方法:
  - 定义形式:
  
  ```java
  // 修饰符 返回值类型   方法名  形式参数
  public static int sum(int a , int b) {
        int c = a + b;  // 直销代码
        return c;       // 返回值
    }
  // 请他形式方法

  ```

- 无参数,无返回值写法
- 如何调用方法:
  - 方法名();
- 案例
- 内存原理
  - 没有调用在方法区
  - 在方法被调用的时候,需要进入栈内存.
  ![方法](Method1.png)
  ![方法2](Method2.png)
  ![方法3](Method3.png)
- 方法参数
  - 基本类型参数传递
    - 值传递,传输的不是实参变量本身,而是其存储的值
    ![参数](prama.png)
  - 引用类型参数传递
    - 数组,是变量本身的传递,而非值得传递,即变量内容方法可改变.
    ![参数2](prama1.png)
  - 都是传值,基本传的是数据只,引用传的地址值
- 参数案例
  - 打印数组的内容方法---该数组:[11,22,33,44]
  - 从数组中查询元素的索引返回
  - 比较两个数组是否一样
- 方法重载,return
  - 方法重载:
  - 同一个类中,出现过个方法名相同,但形式不一样,就是方法重载.
  - 方法重载的识别技巧:
    - 方法名相同,形参不同
    - 形参的个数.类型,顺序不同
    - return 关键字,单独使用

## 综合案列

- 变量,数组;运算符的使用;程序流程控制;跳转关键字的使用;方法
- 编程思维,模仿,学习,创造.
- 案例 一: 买飞机票
- 案例 二: 找素数
- 案例 三: 开发验证码
- 案列 四:数组元素的复制
- 案例 五:评委打分
- 案例 六:数字加密
- 案例 七:模拟双色球

## **面向对象编程(基础)**

- 一种编程思想;
- 人类思维,理解,操作简单
- 获取已有对象,学习自己设计对象
  
#### 设计对象

- 设计,创建对象
- 设计类: 是对象共同特征的描述,对象是真实存在的具体实例;
- 成员变量--代表属性
- 成员方法--代表行为
  ![类](class.png)
- 构造器
- 代码块
- 内部类
- 定义类的几个补充注意事项
  - 成员变量一般无需指定初始化,存在默认值
    ![类1](clas1s.png)
  - 类首字母大写,驼峰模式
  - 一个代码可以多个类,但只允许一个public 类,且public类要与文件名一致.
  - 建议一个文件定义一个class
  - 修饰符 数据类型 成员名 = 初始化只

#### 对象内存图
  
- 对个对象内存的工作原理
  ![类](clas2s.png)
  - 对象存放在堆内存
  - 成员变量在对象中,存在堆内存.
  - 两个变量指向一个对象.
    ![类3](class3.png)
  - 垃圾回收机制:
    - 当堆内存的对象和数组,没有被任何变量应用(指向)是,就会被判定为内存垃圾
    - java存在的自动垃圾回收器,定期会进行清理

#### 面向对象编程训练

- 模拟购物车模块
- 老师写的不太好,应该想办法先写查询,利用查询写添加,修改等等
- 而不是单独在写一个gebyid的方法.
- 整个模块太繁杂.

#### 构造器

- 对象具体调用
- 掌握属性赋值
- 构造器:用于初始化一个类的对象,并返回对象地址
- ```Car c = new Car();```

  ```java
  public class Car(){
    // 无参数构造器
    public Car(){

    }
    // 有参数构造器
    public Car(String n, String b)
    }
  }
  ```

- 类中默认含有无惨构造器
- 有有参数构造器,就必须手动写一个无参数构造器才能调用

#### **this 关键字**

- 作用:出现在成员方法/构造器中代表当前对象的地址,
- 用于访问当前对象的成员变量/成员方法.
- this 出现在有参数构造器中的用法:
  - this.name ; this price;
- this 成员方法中
  - this.name
  ![this](this.png)

#### 封装

- 面向对象的三大特征之一:封装/集成,多态
- 影藏细节,暴露出合适的访问方式
- private(私有)关键字进行隐藏,只能在当前类中访问
- 给他一个public 修饰的公开的getter,setter方法进行暴露给外包取值和赋值.

#### 标准Javabean

- 实体类,起对象可以用于在程序中封装数据
- 满足 成员变量用private修饰
- 提供成套的set,get
- 必须提供一个无参数构造器

#### 使用标准 JavaBean 改造购物车模块

#### 补充知识:成员变量/局部变量的区别

![变量](variable.png)

## 常用API(应用程序编程接口)

- String / ArrayList
- String 字符串存储,很多字符串的操作.
  - 定义变量
  - 指向字符串对象,并操作
  - ```String name = "sdjfalskdj"```
  - 对象创建后不能被更改
  - 字符串常量池--在堆里面/内存原理
  - ![字符串](String-1.png)
  - 创建字符串对象(两种方式)

    ```java
    String bianliang = "xxxx";
    public String()
    public String(Sting original)
    public String(char[] chs)
    public String(byte[] chs)
    
    ```

  - ""方式给出的字符串对象,在字符串常量池中存储,而且相同内容只会在其中存储一份
  - 通过构造器new对象,每new一次都会产生一个新对象,放在堆内存中
  ![zif](String-2.png)
  ![zif](String-3.png)
  - 面试题:
  - 常用API,字符串比较
  - "==" 比较的是变量的指向地址(基本数据类型用就可以)
  - equals 比较内容,不关心地址,业务实际需求
  - 功能:遍历,替换,截取,相等,包含
    ![zif](String-4.png)
  - 解决实际问题
    - 开发验证码功能
    - 模拟用户登录功能
    - 手机号码屏蔽
- ArrayList,集合大小不固定
  - 数组类型,长度就固定了;实际业务场景不太好用
  - 大小,类型不固定,提供丰富的API;
  - 定义,创建
    - ArrayList,支持索引的一种集合;
    - 构造器来创建;
    - 泛型,ArrayList<E>,约定对象只能操作某种数据类型
    - ArrayList<Sting>:次集合只能操作字符串类型元素
    - 集中只能存储引用类型,不支持基本数据类型
    - ![arraylist](first/array1ist.pngrray1ist.png)
  - 功能:添加,获取,删除,修改
    - 遍历倒着删除,不出问题
  - 存储自定义对象,底层原理
  - ![arraylist](array04.png)
  - 结合元素的搜索
  - 学生ID查找案列
  - 解决实际问题
  - ATM取款案例

## 进阶知识

- javaSE 加强课程
  - 深入的面相对象的知识
  - ![课程](课程.png)  
- IDEA 开发模式的统一
- ![IDA](IDEA.png)
- 面相对象的复习

## ATM 系统

- 功能介绍:
- 面相对象编辑
- 试用集合
- 流程控制\
- API相关知识

## 面向对象进阶

- static关键字
  - 作用,修饰成员变量的用法
  - 静态,只在内存存在一份,可以被共享访问和修改
  - 静态成员变量,属于类,内存加载一次
  - 实例成员变量,(name,age等)

![static](class_tst/static-1.png)

- 设计模式: 单列
- 三大特征之一: 继承
- 记住语法,思路,流程 - 解决实际用题

- 静态方法
  - 静态成员方法
  - 实例成员方法
- 表示对象自己的行为,实例方法;执行一个通用的功能为目的,或者需要方便访问
- 内存原理图

![staticmothd](class_tst/staticmothd.png)

- 建议静态方法私有化,不对外产生对象
- 注意事项:
  - 静态只能访问静态成员变量
  - 实例方法可以访问静态方法,也可以访问静态变量
  - 静态方法不能有this 关键字的

- 代码块,类的5大成员之一(成员变量,构造器,方法,代码块,内部类),定义在类中方法外
- 在JAVA 中使用{}括起来的内容为代码块
- 代码块分类
  - 静态代码块
  - 格式: static{}
  - 使用static关键字修饰,随着类加载而加载,并且自动触发,只执行一次
  - 在类加载的时候做一些静态数据初始化的操作,以便使用
- 构造代码块(了解,用的少)
- 设计模式
- 单列:
  - 可以保证系统中,应用改模式的这个类永远只有一个实例,即一个类只有一个实例
  - 任务管理器就只有一个对象
  - 饿汉单列,懒汉单列: 用类获取对象是,对象已经提前创建了
  - 格式: 定义一个类,把构造器私有;定义一个静态变量存储对象

## 继承(面向对象三大之一)

- 继承是类与类的关系
- 多个类可以继承当个类,多个类可以使用单独类的属性和方法
- 多个类叫做子类(派生类),单独的类是父类(基类,超类)
  - extend关键字,继承父类的属性和方法
- 继承的规范:
  - 子类的相同属性和方法(共性)放到父类去定义,子类单独定义自己的其他属性和方法
- 案例:
  - 学生信息/老师信息
- 特点:
  - 子类继承父类的属性和方法,子类不继承父类构造器
  - 子类是否可以继承父类的私有成员变量:可以的
  - 子类是否可以继承父类的静态成员,可以直接使用(属于类的,不算继承)
  - JAVA是单继承
  - 不支持多继承,但支持多层继承
  - JAVA中所有类,直接继承object,或者默认继承object,object是祖宗类.
- 子类访问成员:就近原则
  - 局部范围---子类范围--父类范围 访问机制
- 继承: 方法重写
  - 子类出现父类中一模一样的方法,就称为方法重写
  - 父类不满足子类的需求,即可重写子类的方法
  - (个人思考) 纯方法的重写(无参数,有参数,有参数顺序不同)
  - ```@override```重写注解
  - 方法名,参数列表要一样才能算是重写
  - 私有方法是不能不重写的
  - 重写方法,访问权限必须大于或者等于父类(缺省 < protected < public)
  - 子类不能重写类父类的静态方法
- 子类构造器的特点:
  - 子类所有的构造器都默认会先访问父类中的无惨构造器,在执行
  - 子类初始化时,有可能会使用到父类中的数据,如果没有完成父类成员的初始化,子类将无法使用父类的数据
  - 子类初始化前,一定要调用父类构造器(先完成父类数据空间的初始化)
  - 子类构造器,默认有调用super()构造器
- 子类访问有参父类构造器
  - 初始化继承父类的数据,有参构造器,
  - 在子类构造器中手动书写super(),手动调用父类的有参构造器,先完成父类的数据初始化.
- this super关键字的总结
  - this 访问成员变量,本类方法,本类构造器
  - super 访问成员变量,父类方法,父类构造器
- 包/权限访问
- final 关键字
- 常量
- 枚举,枚举的作用
  - 枚举是之中特殊类型,不是存数据,试做信息的标志和信息的分类
  -

   ```java
  Enum Season{
    SPRING, SUMMER, AUTUMN, WINTER;
  }
  ```

  - 枚举类都是继承枚举类型:java.lang.Enum
  - 枚举都是最终类,不可以被继承
  - 枚举的构造器都是私有的,不可以在外面创建对象
  - 枚举一般默认都是第一行罗列枚举对象名称
- 抽象类
  - 多个子类的各个功能都不太一样,这个时候父类只完成最基本的定义,其他有子类来完成其功能,这种父类就被称作抽象类
  - abstract 关键字来定义.
  - 抽象方法:
    - 抽象类中必须完成子类的基本功能
    - 没有方法体,只有方法签名必须使用abstract修饰
    - 子类一定能是重写抽象类的方法
    - 并且抽象类中的方法,子类不行全部继承重写
  - 特征:
    - 有得有失:得到创建方法,失去创建类;**(不能实例化)**
    - 类有成员抽象发放都有
    - 抽象类不一定有抽象方法
    - 必须全部重写类中的抽象方法
    - abstract 不能修饰变量,代码块,构造器
    - abstract 与 final是互斥关系
    - abstract定义的类作为模板被继承,定义的方法需要被重写
    - final 定义的类不能被继承,定义的方法不能被重写
- 模板设计模式(单列设计模式)

## 接口

- 特点--抽象方法定义的一组行为规范,一种纯粹的类.
- 是这类实物,必须完成某些行为
- 代码的定义
- jdk8之前之后的定义不太同
-
-
- ```java
  // jdk8 之前:
  public interface 接口名{
    //只能定义:
    // 1.常量
    // 2.抽象方法
  }
  // 不能沟通实例化
  //jdk8之后:
  ```

- 接口基本使用,是被类来实现的(implements),实现接口的类称为实现类.
```修饰符 class 实现类 implements 接口1,接口2...{}```
- 一个实现类,必须全部重写所有方法(..)
- 接口与接口的关系:多继承的
  - 类与类 ,但继承
  - 类与接口,多实现,多继承
  - 多继承接口的抽象方法类型,方法名相同,就不冲突
- jdk8开始接口新增的方法
  - 接口的成员方法进行了新增
  - 抽象方法有新功能,必须重写,不利于继承类的代码维护
  - 解决: (默认方法):支持写方法体在接口(普通方法,用default修饰)
  - 静态方法: 默认public 必须使用static修饰
  - 接口的静态方法必须用本身的接口名来调用
  - 私有方法: 必须用private修饰,jdk9
  - 只能在本类中被其他的默认方法或者私有方法访问
- 注意事项:
  - 1/接口不能创建对象(接口是更加彻底的抽象)
  - 2/一个类实现多个接口,多个接口可以同样的静态方法,不冲突(因为接口的静态方法只有接口名可以调用,创建的实例也调用不了)
  - 3/一个类继承了父类,同时又实现了多个接口,父类中和接口中有同名方法,默认用父类的方法
  - 4/一个类实现了多个接口,多个接口中存在同时的默认方法(default),不冲突,这个类重写该方法即可
  - 5/一个接口继承多个接口是没有问题的.如果多个接口中存在规范冲突则不能继承.

## 多态(三大之一)

- 同类型的对象,执行用一个行为,会表现出不同的行为特征
- 多态的常见形式
- 父类类型 对象名称 = new 子类构造器
- 接口 对象名称 = new 实现类构造器
- 多态中的成员访问特点
  - 方法: 编译看左边,运行看右边
  - 变量: 编译看左边,运行也看左边
  - 强调方法多态,变量不多态.
- 前提:有继承/实现关系,父类指向子类对象,有方法重写
- 多态的优势
  - 在多态的形式下,右边的对象可以实现解耦合(切换),便于扩展和维护
  - 定义方法的时候,使用父类型作为参数,该方法就可以接受这个父类的一切子类对象,体现多态的扩展性与便利(对象回调)
  - 多态下不能使用之类的独有的功能
  - 多态下引用数据类型的转换
    - 自动类型转化,子类对象赋值给赋值给父类型的变量转换(向上)
    - 强类型转换(向下):子类 对象变了 = (子类)父类类型的变量,可以实现子类中的独有的方法.

## 内部类

``` java
public class outer{
  public class inter{
    
  }
}
```

- 内部类可以访问外部类的成员变量,方法
- 静态/成员/局部/匿名 内部类(重点)
- 静态内部类:
  - 由static 关键字修饰,属于外部类本省
  - 可以访问外部类的静态成员
  - 不可以访问外部类的实例成员,成员变量是对象的,不能直接访问
- 成员内部类
  - 无static修饰,属于外部类的对象(实例)
  - 可以访问外部类的静态成员
  - 内部类访问外部类的实例成员--可以的
- 局部内部类
  - 放在方法,代码块,构造器执行体中
  - 外部类$N内部类.class
- 匿名内部类(重点)
  - 没有名字的局部内部类,定义在方中,代码块中等等
  - 方便创建子类对象,最终目的为了简化代码编写
  
  ```java
  new 类\抽象类名\接口(){
    重写方法
  }
  ```

  - 没有名字的内部类
  - 写出内部类就会产生一个匿名的对象
  - 匿名对象的类型相对于new类的子类类型
- 匿名内部类常见使用形式
  - 匿名内部类可以当成参数使用
- 实际场景
  - 给按钮绑定点击事件

## 常用API

- Object
  - toString() 类名的地址,可以重写显示对象中的内容
  - equals() 默认比较两个对象的地址是否一直,(==)也可以比较地址
  - 更多的想比较两个对象的内容,子类可以重写定义equals的方法
  - objects 类,,objects.equals.(对象1,对象2),更为安全
- StringBuilder 可变字符串,一个对象容器,只是手段,最后还是需要String的类型
  - 拼接,修改
  - String类萍姐字符串原理图:
  - 不断在堆内存新建内存.不断改变指向.
  - StringBuilder 在堆里只创建一个对象,在一个字符串常量池拼接,效率搞,内存少.
- 案例: 打印整数型数组的内容
- math 类,没有提供公开的构造器,不能创建对象,是一个工具类
  - 功能:
- System 类,不能创建对象,是静态的方法,也是一个工具类
  - 静态方法,用类名调
- BigDecimal 浮点数精度解决问题,可以创建对象,但不建议.
- 时间API
  - 古老时间
  - Date类:当前系统的时间
  - date();SimpleDateFormat()
  - 日期对象,字符串--parse,格式需要一直.
  - 案例
  - calendar 抽象类,不能直接创建类
  - JDK8新增日期时间
    - localDate/localTime/localDateTime/instant/DateTimeFormatter/Duration/Period
    - 新API类型几乎全部是不变的类型
- 认识包装类(8种基本类型对象化,集合,泛型不支持基本类似,怎么解决)
  - 自动装箱,自动拆箱
  - 把基本类型转化成字符串类型
  - 把字符串类型转化成真实数据类型(重点)
  - 容错搞,包装类型 = null
- 正则表达式
  - 校验输入的合法性
  - 体验一个QQ号码是否争正确,6-20为,全部是数字
  - 匹配的规则
    - 字符类(默认匹配一个字符)
    - 预定义的字符类型(默认匹配一个)
    - 贪婪的量词(配合匹配多个)
    - API----x.matches(regex:  )
    - ? 一次或者没有
    - * 零次或者多次
    - + 一次或者多次
    - x[n] n次
    - x{n,}至少 n
    - x{n,m},至少n ,至多 m
- 快速操作数组元素(Array类)
  - API:
  - toString(类型[] a)
  - sort()/sort(comparator)
  - binarySearch()
  - Comparator比较器的支持
- 常见算发
  - 选择排序
  - 二分查找
- Lamada表达式(简化技术--匿名内部函数)
- (形参) -> (方法体)
- **简化 函数式接口,并且只有一个抽象方法**
  - 参数类型可以不写
  - 只有一个参数,类型可省,()可胜率
  - lambda 方法体只有一行代码,可以省略大括号,分号;
  - lambda 方法体只有一行代码,大括号省略,return 省略,;号省略.

## 集合的概述

- 集合和数组都是容器
  - 数字,类型确定,长度固定
  - 数组进行操作都不太合适,需要移位
  - 业务数据固定,同一批类型的时候,可采取
  - 可存储基本类型和引用类型
- 集合是JAva中存储对象数据的容器
  - 大小不固定,动态变化,类型也可以不固定
  - 元素的增删操作
  - 集合只能存储应用类型的数据,基本数据可以用包装类
  - API比较丰富.

### collection 集合的体系结构(接口...是接口)

- 集合 - collection(单列)--list + set
-     - map(双列)      ArrayList    hashset treeset     
-                                  LinkedHashset
- List :元素有序,可重复,有索引(**是接口**)
  - ArrayList,LinkedList  : 有序,重复,索引,底层结构不一样(**实现类**)
- Set : 元素无序,不重复,无索引(**是接口**)
  - HashSet:(**实现类**)
    - LinkedHashset: 有序,不重复,无索引
    - Treeset:按照大小默认升序排列,不重复,无索引

- 集合对于泛型的支持<E>
- 可在编译<写入类型> new 后面的可以省略
- 引用数据类型,对象.集合与泛型不支持基本类型

### 常用API

- Collection 集合API:
- 遍历:
  - foreach 循环的写法
  - 迭代器
  - lambda forEach()方法   变量名.forEach(action)
- collection 集合存储自定义类型的对象
  
### 常见数据结构

- 计算机底层存储,组织数据的方式,是指数据互相之间是以什么方式排列在一起的
- 数据结构:栈,队列
  - 栈:LIFO;压栈,进栈;弹/出栈;
  - 队列:FIFO;入列,出列
- 数组,链表
  - 数组:内存中的一块连续的区域,长度,索引,类型:查询速度块(索引来查询)
  - 增加,删除数组的效率低,有移位的操作
  - 链表:内存中不连续存储,每个元素都包含数据值和一下个元素的地址
  - 结点(数据,下一个元素的地址)->
  - 查询比较慢的数据结构,增加删除数据较快的.
  - 单向列表,双向列表(用的比较多)
- 二叉树,二叉树查找
  - 最多有两个结点
  - 左结点< 父结点 < 右结点
  - 相关概念:根节点,子树
  - 结点度(子树的个数)
  - 高度: 叶子结点高度为 1,叶子结点的父结点高度为2
  - 层:根结点为第一层
  - 兄弟结点:拥有共同父节点的结点
  - 二叉查找树---排序树,搜索树
- 平衡二叉树
  - 降低层数
  - 任意结点的高度差不超过1,任意结点的左右两个子树都是一个二叉树.
  - 左旋,右旋保持平衡
  - 那边高,拉另一边
- 红黑树
  - 一种自平衡二叉树
  - 每一结点都可以是红或黑,不是通过高度平衡的.红黑规则
  - 每一个节点或是红色,黑色,根结点必须是黑色
  - 如果一个节点没有子节点或者父节点,则该节点相应的指针属性为Nil,这些Nil视为子节点,叶节点是黑色
  - 如果某一个节点是红色,那么他的子节点必须是黑色(不能同时出现两个红色节点相连的情况)
  - 对每一个节点,从该节点到其他所有后代叶节点的简单路劲上,均包含相同数目的黑色节点
  - 默认用红色效率高
  - 添加为红色,(父叔为红色)将父结点和叔叔结点变成黑色, 祖父结点变成红色(根结的化变成黑色)
  - 添加为红色,(父为红,叔为黑),将父结点变成黑色,祖父结点变成红色,在以父结点进行旋转.
- List系列集合
  - ArrayList ,LinkedLish 有序,可重复,有索引,二则底层原理是不一样的.
  - ArrayList,数字实现的,增删慢
  - LinkedList,双链表实现的,首尾操作速度块.
  - API,独特索引的API.
  - 